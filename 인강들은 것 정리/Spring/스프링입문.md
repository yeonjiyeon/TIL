### 1.프로젝트 환경설정

**1-1.프로젝트 환경설정**

:스프링 부트 스타터 사이트로 이동해서 스프링 프로젝트 생성
[https://start.spring.io/](https://start.spring.io/)

-maven or gradle
필요한 라이브러리를 땡겨서 오고 빌드하는 라이프사이클까지 관리해주는 툴
버전설정하고 라이브러리를 땡겨오는 것
요즘은 gradle을 더 많이 사용한다

-> xml이 아닌 java언어로 되어 있어서 더 편하기 때문에
버전은 정식릴리즈된 버전을 쓰는 것이 좋다

-Project Metadata
-Group : 그룹에는 보통 기업 도메인명을 적는다

-Artifact: 어떻게 나올지 결과물

-Dependencies: 어떤 라이브러리를 땡겨서 쓸 것인지 설정

-Thymeleaf: 템플릿 엔진

-파일구조 : main, test 형식으로 되어있다

main에 java, resources
java: 밑에 실제 소스코드들이 있다
resources : 자바파일 외 소스코드들이 들어있다 ex) html
test 코드들과 관련된 소스들이 들어간다, 요즘에는 중요함

```java

sourceCompatibility = '11'  --> 자바버전을 의미한다
repositories {
mavenCentral() 
//*mavenCentral 사이트에서 자동으로 설정한 dependencies를 다운받아준다*
}
dependencies {
implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
implementation 'org.springframework.boot:spring-boot-starter-web'
//설치해줬던 dependencies
testImplementation('org.springframework.boot:spring-boot-starter-test') {
exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
/*자동으로 들어간 테스트 라이브러리 'junit 5번째 버전*/
}

}
```

<build.gradle>

.gitignore : 자동으로 소스코드를 관리해주는 파일이다
@SpringBootApplication : 톰캣 웹서버가 내장되어 있어서 자체적으로 띄우면서 스프링부트가 같이올라온다

settings --> gradle 검색
Build and run using
Run tests using
둘 다 intellij idea 로 바꾸기 --> gradle을 거치지 않고 바로 적용되어서 속도가 향상된다, 설정을 하지 않으면 gradle을 통해 빌드가 되어서 속도가 느려진다

**1-2.라이브러리 살펴보기**
External Libraries: 빌드툴을 통해 다운받은 것들을 보여준다
gradle이나 maven같은 빌드툴들은 의존관계를 관리해 준다 dependencies에서 설치된 것들 중에서필요로 하는 의존들을 자동으로 더 땡겨온다-> 필요한 것들을 모두 땡겨준다-> core까지 이어진다

- spring-boot-starter-web →spring-core --> 코어까지 이어진다
    
    -spring-boot-starter-logging
    현업에서는 로그 출력이 필요하다 --> 현업에서는 System.out.println을 사용하지 않음
    logback, slf4j
    slf4j : 인터페이스
    logback: slf4j 구현, 실제 로그를 어떤 구현체로 출력할 것인가
    

테스트 라이브러리
spring-boot-starter-test
junit: 테스트 프레임워크,자바에서 사용하는 유닛테스트 요즘은 5사용
mockito: 목 라이브러리
assertj: 테스트 코드를 좀 더 편하게 작성하게 도와주는 라이브러리
spring-test: 스프링 통합 테스트 지원

- spring-boot-starter-thymeleaf: 타임리프 템플릿 엔진(View)

**1-3.View 환경설정**
[https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/](https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/)
페이지에서 필요한 것 찾아보기

스프링부트는 스프링생태계을 전반적으로 감싸기 때문에 전반적 생태계를 모두 제공해 준다

<welcome page>
static 파일(정적 파일)에서 index.html을 찾아서 실행한다 

Controller 처음 시작할때 실행된다

스프링 부트가 제공하는 Welcome Page 기능
static/index.html 을 올려두면 Welcome page 기능을 제공한다.
https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-bootfeatures.html#boot-features-spring-mvc-welcome-page

<hello.html>

```html
<html xmlns:th="http://www.thymeleaf.org">
<head>
 <title>Hello</title>
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
<p th:text="'안녕하세요. ' + ${data}" >안녕하세요. 손님</p>
</body>
</html>
```

<helloController>

```java
//Controller
public class HelloController {
@GetMapping("hello")
public String hello(Model model) {
model.addAttribute("data", "hello!!");
return "hello";
}//*hello.html을 찾는다*
}
```



컨트롤러에서 리턴 값으로 문자를 반환하면 `뷰 리졸버`( viewResolver )가 화면을 찾아서 처리한다.
스프링 부트 템플릿엔진 기본 viewName 매핑
resources:templates/ +{ViewName}+ .html

참고: spring-boot-devtools 라이브러리를 추가하면, html 파일을 컴파일만 해주면 서버 재시작 없이 View 파일 변경이 가능하다

**1-4<빌드하고 실행하기>**
cmd창
F:\study\hello-spring\hello-spring 로 이동

명령 프롬프트에서 gradlew.bat 를 실행하려면 gradlew 하고 엔터

gradlew build

폴더 목록 확인 ls dir
gradlew clean build --info
cd build/libs  로 이동

### 2.스프링 웹 개발 기초

**2-1정적 컨텐츠**:서버와 관계없이 파일을 그대로 고객(웹 브라우저)에게 전달해 주는 것

 --> 스프링부트에서 자동으로 제공한다
내장 톰캣 서버가 컨트롤러에서 매핑된 것을 찾지 못한 다면(컨트롤러에 등록x)→ static 파일에서 파일을 찾아서 반환해 준다

```html
<!DOCTYPE HTML>
<html>
<head>
  <title>static content</title>
  <meta http-equiv="Content-Type" content="text/html; charsetㅓ=UTF-8" />
</head><body>
정적 컨텐츠 입니다.
</body>
</html>
```

/hello-static 로 입력하면 그냥 파일 그대로 반환해 준다



 

**2-2 MVC와 템플릿 엔진** : ex)jsp,php처럼  서버에서 프로그래밍해서 html을 동적으로 바꿔서 내려주는 것
model1방식 : view에 모두 작성해 주는 것, 모델과 뷰 분리 안함

vs

model2방식
관심사 분류(aop), 역할과 책임
**view**: 화면을 그리는데 모든 영향을 집중
**model, controller**: 비즈니스 로직과 관련 내부적인 것을 처리하는데 집중해야 한다(뒷단(서버)에서 사용하는 것) 필요한 것을 담아서 화면에 던져준다.

```java

model.addAttribute("data", "hello!!"); //data에 직접 이름을 넣어준다

@GetMapping("hello-mvc") //url에 띄울 이름
public String helloMvc(@RequestParam("name") String name, Model model){
//url의 파라미터를 통해 받아온다
//@RequestParam("name",  required = false) 설정해 주면 값을 넘기지 않아도 에러가 안난다
model.addAttribute("name", name);//name에 파라미터에서 받아온 이름을 넘긴다
return  "hello-template"; //전달할 html파일
} 
```

[http://localhost:8080/hello-mvc?name=spring](http://localhost:8080/hello-mvc?name=spring)!!
viewResolver: 화면에 관련된 해결자
정적 소스는 변환과정이 없지만 템플릿 엔진은 변환과정이 존재함

변환해서 랜더링해준다

thymeleaf —> 파일 열어서 내용물 볼 수 있음 jsp와 다르게,,,

```html
<html xmlns:th="http://www.thymeleaf.org">
<body>
<p th:text="'hello ' + ${name}">hello! empty</p>
</body>
</html>
```



**2-3. API** : 데이터구조 포멧(json, xml)으로 클라이언트에게 데이터를 전달하는 방식,데이터를 html을 통하지 않고 바로 내리는 것

ex) vue,react적용하거나 서버끼리 통신할때 많이 사용한다

```java
@GetMapping("hello-string")//문자사용할때
    @ResponseBody
    public String helloString(@RequestParam("name") String name){
        return "hello " + name;//데이터를 문자 그대로 내려준다
    }

*@GetMapping("hello-api")//데이터 사용할때
@ResponseBody
public Hello helloApi(@RequestParam("name") String name){
    Hello hello = new Hello();
    hello.setName(name);
    return hello;//객체를 넘긴다, json형태(*{"name":"spring!!"} 키 값 구조*)로 나온다
}

static class  Hello {
    private  String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}*
```

@ResponseBody
 http에서 body부분에 데이터(응답)를 직접 넣어 준다는 의미,
 뷰를 만들 필요 없이 문자가 바로 적용된다

- xml 방식:무겁고 태그사용으로 번거로움 —> 최근 JSON 방식이 더 많아짐
- getter,setter :자바빈 표준 방식, property 접근 방식, 변수 직접 변경 못하고 메서드를 통해서 변경시키기 위해 사용한다



controller가 url을 템플릿 엔진에서 찾지만
`@ResponseBody가 있는 경우` 그대로 응답에 그대로 데이터를 던져 넣는다. 하지만 `객체인 경우`에는 json방식으로 데이터를 만들어서 http에 응답을 함

@ResponseBody 를 사용
HTTP의 BODY에 문자 내용을 직접 반환
viewResolver 대신에 HttpMessageConverter 가 동작
기본 문자처리: StringHttpMessageConverter
기본 객체처리: MappingJackson2HttpMessageConverter
byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음

*json으로 바꿔주는 라이브러리: Jackson(스프링에서 기본), gson

### 3.회원 관리 예제 - 백엔드 개발

**3-1. 비즈니스 요구사항 정리**

<일반적인 웹 애플리케이션 계층 구조>

컨트롤러: 웹 MVC의 컨트롤러 역할



**서비스**: 서비스클래스의 핵심 비즈니스 로직 구현 예) 회원은 중복가입이 안된다 등등의 로직
**비즈니스**: 도메인객체를 가지고 핵심 비즈니스 로직이 동작하도록 구현한 계층
**리포지토리**: 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리
**도메인**: 데이터베이스에 저장하고 관리되는 비즈니스 도메인 객체,
예) 회원, 주문, 쿠폰 등등 주로 데이터베이스에 저장하고 관리



아직 데이터 저장소가 선정되지 않아서, 우선 인터페이스로 구현 클래스를 변경할 수 있도록 설계
--> 인터페이스로 만들어 놓으면 나중에 데이터베이스변경이 가능하다

**3-2회원 도메인과 리포지토리 만들기**

domain Member.java

repository : 인터페이스를 만들어 준다 

```java
public interface MemberRepository {
    Member save(Member member);//회원저장시 저장된 회원 반환
    //Optional(java8) null을 그대로 반환되지 않게 감싸서 반환하기 위해 사용한다
    Optional<Member> findById(Long id);//id찾기
    Optional<Member> findByName(String name);
    List<Member> findAll();//조회
}
```

repository 구현

```java
public class MemoryMemberRepository implements MemberRepository{

    private static Map<Long, Member>store= new HashMap<>();
    private static long sequence= 0L;//키값을 생성하기v 위해 사용한다
    @Override
    public Member save(Member member) {
        member.setId(++sequence);//sequence값증가
store.put(member.getId(),member);//member는 name으로 받아온다
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.ofNullable(store.get(id));//null반환을 위해 사용한다
    }

    @Override
    public Optional<Member> findByName(String name) {
        return store.values().stream().filter(member -> member.getName().equals(name)).findAny();//findAny하나라도 찾는 것
    }

    @Override
    public List<Member> findAll() {
        return new ArrayList<>(store.values());//member들 반환
    }

    public void clearStore(){
store.clear();
    }
}
```

**3-3회원 리포지토리 테스트 케이스 작성**

<회원 리포지토리 테스트 케이스 작성>
개발한 기능을 실행해서 테스트 할 때 자바의 `main 메서드`를 통해서 실행하거나, 웹 애플리케이션의 `컨트롤러`를 통해서 해당 기능을 실행한다. 이러한 방법은 준비하고 실행하는데 오래 걸리고, 반복 실행하기 어렵고 여러 테스트를 한번에 실행하기 어렵다는 단점이 있다. 자바는 JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결한다

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class MemoryMemberRepositoryTest {
    MemoryMemberRepository repository = new MemoryMemberRepository();

    @AfterEach
    public void afterEach() {//테스트 메서드가 실행 된 후 실행되는 함수
        repository.clearStore();//순서에 영향을 받지 않게 하기 위해 각각 테스트후 메모리를 비워주는 함수
    }

    @Test
    public void save(){
        //given
        Member member = new Member();
        member.setName(("spring"));

        //when
        repository.save(member);

        //then
        Member result = repository.findById(member.getId()).get();
        //optional에서 꺼낼 때는 get사용
        // System.out.println("result = " + (result == member));
        //Assertions.assertEquals(member, result);// 기대값== 실제값 (문자가 아니라 실제값을 바교할 수 있다)
assertThat(result).isEqualTo(member);//static import
    }

    @Test
    public void findByName(){
        //given
        Member member1 = new Member();
        member1.setName("spring1");
        repository.save(member1);

        Member member2 = new Member();
        member2.setName("spring2");
        repository.save(member2);

        //when
        Member result = repository.findByName("spring1").get();

        //then
assertThat(result).isEqualTo(member1);
    }

    @Test
    public void findAll(){
        //given
        Member member1 = new Member();
        member1.setName("spring1");
        repository.save(member1);

        Member member2 = new Member();
        member2.setName("spring2");
        repository.save(member2);

        //when
        List<Member> result = repository.findAll();

        //then
assertThat(result.size()).isEqualTo(2);
    }
}

```

테스트는 순서에 대한 의존 관계없이 설계가 되어야 한다
--> 순서에 영향을 받지 않게 해줘야 한다

```java
public void clearStore(){//test가 하나 끝날때마다 저장소를 비워줘야 한다
store.clear();
}
```

**3-4회원 서비스 개발**
실제 비즈니스 로직을 구현하는 법, 비즈니스에 의존적으로 메서드를 작성,

mapper(repository)는 개발에 가깝게 작성해 준다

```java
package hello.hellospring.service;
import hello.hellospring.domain.Member;
import hello.hellospring.repository.MemberRepository;
import hello.hellospring.repository.MemoryMemberRepository;

import java.util.List;
import java.util.Optional;
public class MemberService {
    //private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final MemberRepository memberRepository;

    public MemberService(MemberRepository memberRepository) {
        //r
        this.memberRepository = memberRepository;
    } //외부에서 넣어주도록 바꿔준다

/**
     *회원가입
*/
public Long join(Member member) {
        //같은 이름이 있는 중복회원x
        validateDuplicateMember(member); //중복 회원 검증
        memberRepository.save(member);
        return member.getId();
    }

    private void validateDuplicateMember(Member member) {
//Optional<Member> result = memberRepository.findByname(member.getName());이지만 
//반환값이 어차피 Optional이기때문에 변수에 넣지 않고 바로 적용한다. ifPresent은 Optional에서
//사용가능함
        memberRepository.findByName(member.getName())
                .ifPresent(m -> {//memer에 값이 있으면(null이 아니면) 밑의 예외를 반환
                    throw new IllegalStateException("이미 존재하는 회원입니다.");
                });
    }
/**
     *전체 회원 조회
*/
public List<Member> findMembers() {
        return memberRepository.findAll();
    }
    public Optional<Member> findOne(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

**3-5회원 서비스 테스트**
클래스명에 마우스 위치 후, alt + enter --> 테스트 클래스 자동생성

test는 한글로 작성해도 괜찮다, test코드는 빌드시에 포함되지 않다.

```java
package hello.hellospring.service;
import hello.hellospring.domain.Member;
import hello.hellospring.repository.MemoryMemberRepository;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;

class MemberServiceTest {
    MemberService memberService;
    //MemoryMemberRepository memberRepository = new MemoryMemberRepository();
    //객체 생성을 다시 하여서 MemberService에서 생성한 memberRepository 다른 인스턴스가 된다
    //다른 레파지토리를 
    MemoryMemberRepository memberRepository;

    
    //동작하기 전에 넣어주기
    //외부에서 객체를 넣어주도록 처리한다 DI
    @BeforeEach
    public void beforeEach() {
        memberRepository = new MemoryMemberRepository();
        memberService = new MemberService(memberRepository);//생성자에 넣어준다
    }

    @AfterEach
    public void afterEach() {//레포지토리 초기화를 해준다
        memberRepository.clearStore();
    }
    
    @Test
    public void 회원가입() throws Exception {//join 테스트에서는 한글로 바꾸어도 괜찮음
        //Given 어떤 데이터를 기반으로 하는지
        Member member = new Member();
        member.setName("spring");

        //When 어떤것을 검증하는지
        Long saveId = memberService.join(member);

        //Then
        Member findMember  = memberService.findOne(saveId).get();
        assertThat(member.getName()).isEqualTo(findMember.getName());
    }

    @Test
    public void 중복_회원_예외() throws Exception {//예외 사항에 대한 검증도 중요하다!!!
        //Given
        Member member1= new Member();
        member1.setName("spring");

        Member member2= new Member();
        member2.setName("spring");

        //When
        memberService.join(member1);
//        try{
//            memberService.join(member2);
//            fail();
//        }catch (IllegalStateException e){
//            assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
//        } --> 결과가 애매함

        IllegalStateException e = assertThrows(IllegalStateException.class,
                () -> memberService.join(member2));//예외가 발생해야 한다
        assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
    }
}
```

}

```java
public class MemberService {
 private final MemberRepository memberRepository;
 public MemberService(MemberRepository memberRepository) {//
 this.memberRepository = memberRepository;
 }
 ...
}
```

build될때 test코드는 포함되지 않음

### 4. **스프링 빈과 의존관계**

**4-1 컴포넌트 스캔과 자동 의존관계 설정**

스프링 컨테이너(memberController—> memberService —> memberRepository)

controller : memberservice를 통해 작업하는 것을 의존 관계가 있다라고 한다

스프링 컨테이너:MemberController 객체를 생성해서 넣어둔다(관리한다)-->컨테이너가 빈을 관리된다

<**스프링 빈을 등록하는 2가지 방법**>
👉🏼1.컴포넌트 스캔과 자동 의존관계 설정 @(애노테이션)사용해서

👉🏼2.자바 코드로 직접 스프링 빈 등록하기

<**컴포넌트 스캔 원리**>

컴포넌트스캔:객체 생성해서 스프링안에 들어있는 것이다

—> 모든 클래스에 **@Component**을 넣으면 스프링 컨테이너에 넣을 수 있을까? no, @SpringBootApplication(안에 componentscan이 등록되어 있다) 붙은 클래스가 있는 패키지에서만 생성이 가능하다(예제는 hello.hellospring)
**@Component** 애노테이션이 있으면 스프링 빈으로 자동 등록된다.
@Controller 컨트롤러가 스프링 빈으로 자동 등록된 이유도 컴포넌트 스캔 때문이다.
@Component 를 포함하는 다음 애노테이션도 스프링 빈으로 자동 등록된다.
@Controller

```java
package hello.hellospring.controller;

import hello.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller//spring container(큰 통?)가 스프링창이 뜰 때 MemberController 객체를 생성해서 넣어둔다-->스프링 빈이 관리된다
public class MemberController {
    //private final MemberService memberService = new MemberService();
    // 여러개의 객체 생성이 가능하기에 스프링 컨테이너에 등록하고 쓰는 것이 좋다
    private final MemberService memberService;

    @Autowired//스프링이 스프링컨테이너에 있는 memberService와 연결을 시켜준다 di의존성 주입을 해주는것
    public MemberController(MemberService memberService){
        this.memberService = memberService;
    }

}

```

@Service

```java

@Service //스프링컨테이너에 서비스를 등록한다, 서비스를 등록해야 컨테이너에서 싱글톤으로 관리될 //수 있다
public class MemberService {
    //private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final MemberRepository memberRepository;

    @Autowired //스프링컨테이너에 있는 멤버리포지토를 서비스에 주입해준다
    public MemberService(MemberRepository memberRepository) {
        //
        this.memberRepository = memberRepository;
    } //외부에서 넣어주도록 바꿔준다
```

```java
@Repository//스프링 컨테이너에 등록
public class MemoryMemberRepository implements MemberRepository
```

생성자에 **@Autowired** 가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다. 이렇게 객체 의존관계를 외부에서 넣어주는 것을 **DI (Dependency Injection), 의존성 주입**이라 한다.
이전 테스트에서는 개발자가 직접 주입했고, 여기서는 @Autowired에 의해 스프링이 주입해준다

참고: 생성자에 @Autowired 를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서
주입한다. 생성자가 1개만 있으면 @Autowired 는 생략할 수 있다.

> 참고: 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 **싱글톤**으로 등록한다(유일하게 하나만 등록해서 공유한다) 따라서 같은 스프링 빈이면 모두 같은 인스턴스다. 설정으로 싱글톤이 아니게 설정할 수 있지만, 특별한 경우를 제외하면 대부분 싱글톤을 사용한다

**4-2 자바 코드로 직접 스프링 빈 등록하기**

<SpringConfig>

```java
package hello.hellospring;

import hello.hellospring.repository.MemberRepository;
import hello.hellospring.repository.MemoryMemberRepository;
import hello.hellospring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SpringConfig {
    @Bean//스프링빈에 직정 등록하기
    public MemberService memberService(){
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository(){
        return new MemoryMemberRepository();//구현체를 넣어준다
    }

}

```

참고: XML로 설정하는 방식도 있지만 최근에는 잘 사용하지 않으므로 생략한다.
> 참고: **DI에는 필드 주입, setter 주입, 생성자 주입** 이렇게 3가지 방법이 있다. 의존관계가 실행중에
동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장한다.

```java
 //1.필드주입
//    @Autowired private MemberService memberService;//필드를 통해 주입하는 것을 필드 주입이라고 한다
    //필드주입은 바꿀 수 있는 방법이 없기에 선호되지 않는다
    //2.setter주입: 단점 누군가 호출했을때 public하게 노출될 수 있다(메서드를 public으로 열려 있으므로) 로딩시점에 바꾸게 해야한다
    //조립시점에만 한번만 넣을 수 있게 만드는 것이 좋다
    //@Autowired
//    public void setMemberSservice(MemberService memberService){
//        this.memberService = memberService;
//    }
    //3.생성자주입
    @Autowired//스프링이 스프링컨테이너에 있는 memberService와 연결을 시켜준다 di의존성 주입을 해주는것
    public MemberController(MemberService memberService){//생성자를 통해 주입하는 것을 생성자 주입이라고 한다
        this.memberService = memberService;
        //조립되는(세팅되는) 시점에
```

> 참고: 실무에서는 주로 정**형화된 컨트롤러**, **서비스, 리포지토리 같은 코드는 컴포넌트 스캔**을 사용한다. 
그리고 정형화 되지 않거나, 상황에 따라 **구현 클래스를 변경**해야 하면 설정을 통해 스프링 빈으로
등록한다.
> 주의: @Autowired 를 통한 DI는 helloConroller , memberService 등과 같이 스프링이 관리하는
객체에서만 동작한다. 스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지 않는다

### 5. 회원 관리 예제 - 웹 MVC 개발

**5-1 회원 웹 기능 - 홈 화면 추가**

참고: 컨트롤러가 정적 파일보다 우선순위가 높다.

```java
package hello.hellospring.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
@Controller
public class HomeController {
 @GetMapping("/")
 public String home() {
 return "home";
 }
}
```

**5-2 회원 웹 기능 - 등록**

회원 등록 폼 개발

-get방식: url로 직접 들어가는 것, 조회할 때 주로 사용한다

-post방식: form에 데이터를 넣어서 전달한다 

form안의 name이 키역할을 한다

—> method에 따라 다르게 처리하는 것이 가능하다

```java
@GetMapping(value="/members/new")
public String createForm(){
    return "members/createMemberForm";
}

@PostMapping(value="/members/new")
public String create(MemberForm form){
    Member member = new Member();
    member.setName(form.getName());
    memberService.join(member);
    return "redirect:/";

}
```

회원 등록 폼 HTML 

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<body>
<div class="container">
  <form action="/members/new" method="post">
    <div class="form-group">
      <label for="name">이름</label>
      <input type="text" id="name" name="name" placeholder="이름을
입력하세요">
    </div>
    <button type="submit">등록</button>
  </form>
</div> <!-- /container -->
</body>
</html>
```

**5-3 회원 웹 기능 - 조회**

```java
@GetMapping(value = "/members")
public String list(Model model) {
 List members = memberService.findMembers();
 model.addAttribute("members", members);
 return "members/memberList";
}
```

회원 리스트 HTML

```html
<div class="container">
  <div>
    <table>
      <thead>
      <tr>
        <th>#</th>
        <th>이름</th>
      </tr>
      </thead>
      <tbody>
      <tr th:each="member : ${members}">
        <td th:text="${member.id}"></td>
        <td th:text="${member.name}"></td>
      </tr>
      </tbody>
    </table>
  </div>
</div> <!-- /container -->
</body>
</html>
```

데이터베이스를 구축하지 않았기 때문에 메모리에 임시로 남은 것들을 출력해주는 것이므로 메모리를 내리면 저장된 내용들이 사라진다.

### 6. 스프링 DB 접근 기술

**6-1. H2 데이터베이스 설치**

개발이나 테스트 용도로 가볍고 편리한 DB, 웹 화면 제공

[https://www.h2database.com/html/main.html](https://www.h2database.com/html/main.html)

- 다운로드 및 설치
h2 데이터베이스 버전은 스프링 부트 버전에 맞춘다.
권한 주기: chmod 755 h2.sh (윈도우 사용자는 x)
실행: ./h2.sh (윈도우 사용자는 h2.bat)
- 데이터베이스 파일 생성 방법
jdbc:h2:~/test (최초 한번)
~/test.mv.db 파일 생성 확인
이후부터는 jdbc:h2:tcp://localhost/~/test 이렇게 접속

—>소켓을 사용해서 접속해야 한다

- 에러 발생시 ~/test.mv.db 파일을 지워준다
- 테이블 생성하기
테이블 관리를 위해 프로젝트 루트에 sql/ddl.sql 파일을 생성

```sql
drop table if exists member CASCADE;
create table member
(
 id bigint generated by default as identity,
//by default as identity:자동으로 값채워주기 위해 사용 
 name varchar(255),
 primary key (id)
);
```

**6-2. 순수 jdbc**

<build.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가>

```java
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'//db와 붙을 때 기본적으로 제공하는 클라이언트가 필요하다
```

자바는 기본적으로 db와 연결하기 위해 jdbc가 필요하다!!—> 이것을 가지고 서로 연동을 한다.  

디비에 붙기 위해 접속 정보가 필요하다 —> 요즘에는 스프링부트가 해준다

<resources/application.properties>

```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
```

h2 database는 아이디,비밀번호는 생략가능함

수정을 용이하게 하기 위해서 interface를 사용한다. 

나중에 내용을 바꿀 때 인터페이스 구현체만 바꿔끼우면 됨(어셈블리?)

역할은 Repository인터페이스가 하지만 실현은 구현체가 해준다

```sql
package hello.hellospring.repository;
import hello.hellospring.domain.Member;
import org.springframework.jdbc.datasource.DataSourceUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
public class JdbcMemberRepository implements MemberRepository {
    private final DataSource dataSource;//db에 붙기 위해 필요하다 
    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";//?파라미터와 바인딩

        Connection conn = null;//연결
        PreparedStatement pstmt = null;//sql넣기 위해 사용
        ResultSet rs = null;//결과값 받기
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);//Statement.RETURN_GENERATED_KEYS insert값 얻기 위해 사용
            pstmt.setString(1, member.getName());
            pstmt.executeUpdate();//실제 쿼리작업
            rs = pstmt.getGeneratedKeys();//생성한 키를 꺼낼 수 있다
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);
            rs = pstmt.executeQuery();//조회는  executeQuery사용
            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();
            List<Member> members = new ArrayList<>();
            while(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();//리스트로 담는다 
            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }
            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);//DataSourceUtils을 사용하면 transaction유지에 도움을 준다
    }
    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs)
    {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);
    }
}
```

```java
private DataSource dataSource;
@Autowired
public SpringConfig(DataSource dataSource){
    this.dataSource = dataSource;
```

다향성을 제공한다. —> 구현체를 바꾸는 것

DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어둔다. 그래서 DI를 받을 수 있다.

<**개방-폐쇄 원칙(OCP, Open-Closed Principle)**> —solid원칙
확장에는 열려있고, 수정, 변경에는 닫혀있다.
스프링의 DI (Dependencies Injection)을 사용하면 기**존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경할 수 있다.**

데이터를 DB에 저장하므로 스프링 서버를 다시 실행해도 데이터가 안전하게 저장된다

조립하는 코드를 사용하면 구현 클래스 자체를 변경하지 않을 수 있다

![contain.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fa7f0d1-7a3a-4486-994d-2361fe1ce930/contain.png)

**6-3. 스프링 통합 테스트**

<회원 서비스 스프링 통합 테스트>

실무에서는 test시에는 test용 db를 주로 구축한다

```java
package hello.hellospring.service;

import hello.hellospring.domain.Member;
import hello.hellospring.repository.MemberRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

@SpringBootTest
@Transactional//테스트시 먼저 실행 테스트 종료시 반영시키지 않고 rollback을 해준다
public class MemberServiceIntegrationTest {
    @Autowired  MemberService memberService;//테스트에서는 그냥 필드 주입방식으로도 많이 사용한다  객체생성이 연결되는 것이 아니기 때문에
    @Autowired
    MemberRepository memberRepository;

    @Test
    public void 회원가입() throws Exception {//join 테스트에서는 한글로 바꾸어도 괜찮음
        //Given 어떤 데이터를 기반으로 하는지
        Member member = new Member();
        member.setName("spring");

        //When 어떤것을 검증하는지
        Long saveId = memberService.join(member);

        //Then
        Member findMember  = memberService.findOne(saveId).get();
assertThat(member.getName()).isEqualTo(findMember.getName());
    }

    @Test
    public void 중복_회원_예외() throws Exception {//예외 사항에 대한 검증도 중요하다!!!
        //Given
        Member member1= new Member();
        member1.setName("spring");

        Member member2= new Member();
        member2.setName("spring");

        //When
        memberService.join(member1);
//        try{
//            memberService.join(member2);
//            fail();
//        }catch (IllegalStateException e){
//            assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
//        } --> 결과가 애매함
        IllegalStateException e =assertThrows(IllegalStateException.class,
                () -> memberService.join(member2));//예외가 발생해야 한다
assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
    }

}

```

@SpringBootTest : 스프링 컨테이너와 테스트를 함께 실행한다.
@Transactional : 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다

- 단위 테스트: 스프링 컨테이너 없이 테스트해야 하는 경우가 필요하므로 중요한 작업이다, 순수한 단위 테스트는 꼭 필요한 부분이다
- @Commit : 자동으로 커밋해주기

**6-4. 스프링 jdbc Template**

순수 Jdbc와 동일한 환경설정을 하면 된다. 
스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다. 하지만 SQL은 직접 작생해야 한다 —> 실무에서 많이 사용함

jdbc Template : template  패턴에서 따왔다

 ****

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;

import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public class JdbcTemplateMemberRepository implements MemberRepository{
   private final JdbcTemplate jdbcTemplate;//JdbcTemplate 사용하기 위해 필요

    //@Autowired 생성자가 하나일때는 생략가능
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");//쿼리를 짜지 않아도 만들어 준다-->insert문 생성
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());
        Number key = jdbcInsert.executeAndReturnKey(new
                MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
         List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);//결과를 RowMapper로 매핑해야 한다
         return result.stream().findAny();
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(),name);
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    private RowMapper<Member> memberRowMapper(){//객체생성
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
}

```

**6-5. JPA**

JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해준다.
JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환을 할 수 있다.

spring-boot-starter-data-jpa 는 내부에 jdbc 관련 라이브러리를 포함한다. 따라서 jdbc는 제거해도 된다

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=non

show-sql : JPA가 생성하는 SQL을 출력한다.//jpa가 날리는 sql문을 볼 수 있다
ddl-auto : JPA는 테이블을 자동으로 생성하는 기능을 제공하는데 none 를 사용하면 해당 기능을 끈다.
create 를 사용하면 엔티티 정보를 바탕으로 테이블도 직접 생성해준다. 해보자spring.jpa.hibernate.ddl-auto=create

jpa(자바 진영의 표준 인터페이스) -hibernate(구현체), 구현체마다 성능차이가 약간씩 존재하긴 함

O(object)R(relation)M(mapping)

Member.java

```java
@Entity//JPA 엔티티 매핑,jpa과 관리하는 엔티티
public class Member {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
```

@Entity: jpa에서 관리되는 entitiy라는 뜻

 @Id @GeneratedValue(strategy = GenerationType.IDENTITY):디비가 알아서 primarykey 자동생성해주게 하기 위해 사용 , IDENTITY 디비가 알아서 생성해 주는 것을 identity라고 한다

@Column(name="username") —> username 컬럼과 매핑

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;

import javax.persistence.EntityManager;
import java.util.List;
import java.util.Optional;

public class JpaMemberRepository implements MemberRepository{

    private final EntityManager em;//내부적으로 db랑 통신등을 알아서 해준다

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member);//저장하다는 의미
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class).setParameter("name", name).getResultList();
        return result.stream().findAny();//하나만 찾아서 반환한다
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m form Member m", Member.class).getResultList();
        //객체 자체를 select한다
        //pk기반이 아닌 경우는 jpql(객체를 대상으로 쿼리를 넘기는 것)을 작성해 주어야 한다
    }
}

```

```java
@Transactional
public class MemberService {
```

org.springframework.transaction.annotation.Transactional 를 사용하자.
스프링은 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작하고, 메서드가 정상 종료되면 트랜잭션을 커밋한다. 만약 런타임 예외가 발생하면 롤백한다.
**JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다**

**6-6. 스프링 데이터 JPA**

스프링 데이터 JPA를 사용하면, 기존의 한계를 넘어 마치 마법처럼, 리포지토리에 구현 클래스 없이 인터페이스 만으로 개발을 완료할 수 있습니다. 그리고 반복 개발해온 기본 CRUD 기능도 스프링 데이터JPA가 모두 제공합니다 —> 개발자는 핵심 비즈니스 로직에 집중할 수 있다

스프링 데이터 JPA가 SpringDataJpaMemberRepository 를 스프링 빈으로 자동 등록해준다 

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository {
    //JPQl select m from Member m where m.name = ?
    @Override
    Optional<Member> findByName(String name);
}
인터페이스만 만들면 스프링 데이터 JPA가 SpringDataJpaMemberRepository 를 스프링 빈으로 자동 등록해준다
```

```java
package hello.hellospring;

import hello.hellospring.repository.*;
import hello.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManager;
import javax.sql.DataSource;

@Configuration
public class SpringConfig {
//    //private DataSource dataSource;
//    @Autowired
//    public SpringConfig(DataSource dataSource){
//        this.dataSource = dataSource;
//    }
//    private EntityManager em;
//    @Autowired
//    public SpringConfig(EntityManager em){
//        this.em = em;
//    }

    private final MemberRepository memberRepository;
    public SpringConfig(MemberRepository memberRepository){//스프링 컨테이너가 구현체를 찾는다
        this.memberRepository = memberRepository;
    }
    @Bean//스프링빈에 직정 등록하기
    public MemberService memberService(){
        return new MemberService(memberRepository);
    }

//    @Bean
//    public MemberRepository memberRepository(){
//        //return new MemoryMemberRepository();
        //return new JdbcMemberRepository(dataSource);
        //return new JdbcTemplateMemberRepository(dataSource);
//        return new JpaMemberRepository(em);
//    }

}

```


<스프링 데이터 JPA 제공 기능>
인터페이스를 통한 기본적인 CRUD 

findByName() , findByEmail() 처럼 메서드 이름 만으로 조회 기능 제공
페이징 기능 자동 제공
> 참고: 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용하면 된다. Querydsl을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다. 이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나, 앞서 학습한 스프링 JdbcTemplate를 사용하면 된다

### 7.**AOP**

**7-1. AOP가 필요한 상황**

모든 메소드의 호출 시간을 측정하고 싶다면?
공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern)
회원 가입 시간, 회원 조회 시간을 측정하고 싶다면?

```java
package hello.hellospring.service;
import hello.hellospring.domain.Member;
import hello.hellospring.repository.MemberRepository;
import hello.hellospring.repository.MemoryMemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

//@Service //스프링컨테이너에 서비스를 등록한다
@Transactional
public class MemberService {
    //private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final MemberRepository memberRepository;

    //@Autowired //스프링컨테이너에 있는 멤버리포지토를 서비스에 주입해준다
    public MemberService(MemberRepository memberRepository) {
        //
        this.memberRepository = memberRepository;
    } //외부에서 넣어주도록 바꿔준다

/**
     *회원가입
*/
public Long join(Member member) {
        long start = System.currentTimeMillis();
        try{
            //같은 이름이 있는 중복회원x
            validateDuplicateMember(member); //중복 회원 검증
            memberRepository.save(member);
            return member.getId();
        }finally {
            long finish = System.currentTimeMillis();
            long timeMs = finish - start;
            System.out.println("join =" +timeMs+ "ms");
        }

    }

    private void validateDuplicateMember(Member member) {
        memberRepository.findByName(member.getName())
                .ifPresent(m -> {
                    throw new IllegalStateException("이미 존재하는 회원입니다.");
                });
    }
/**
     *전체 회원 조회
*/
public List<Member> findMembers() {
        long start = System.currentTimeMillis();
        try {
            return memberRepository.findAll();
        }finally {
            long finish = System.currentTimeMillis();
            long timeMs = finish - start;
            System.out.println("findMembers =" +timeMs+ "ms");
        }

    }
    public Optional<Member> findOne(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

<문제>
회원가입, 회원 조회에 시간을 측정하는 기능은 핵심 관심 사항이 아니다.
시간을 측정하는 로직은 공통 관심 사항이다.
시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞여서 유지보수가 어렵다.
시간을 측정하는 로직을 별도의 공통 로직으로 만들기 매우 어렵다.
시간을 측정하는 로직을 변경할 때 모든 로직을 찾아가면서 변경해야 한다.

**7-2. AOP 적용**

AOP: Aspect Oriented Programming
공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern) 분리

![aop.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/70301662-c472-45da-b828-e010a8a2ed0c/aop.png)

시간 측정 AOP 등록

```java

package hello.hellospring.aop;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
@Component//Bean에 등록해야 인지하기 쉬움으로 직접 등록하는 것이 더 좋다
@Aspect
public class TimeTraceAop {
 @Around("execution(* hello.hellospring..*(..))")
//Around 어디에 적용할지 타겟팅을 하기 위해 사용한다, 파라미터에 원하는 조건을 적는다
 public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {
 long start = System.currentTimeMillis();
 System.out.println("START: " + joinPoint.toString());
 try {
 return joinPoint.proceed();//다음 메서드 진행
 } finally {
 long finish = System.currentTimeMillis();
 long timeMs = finish - start;
 System.out.println("END: " + joinPoint.toString()+ " " + timeMs +
"ms");
 }
 }
}
```

**해결**
회원가입, 회원 조회등 핵심 관심사항과 시간을 측정하는 공통 관심 사항을 분리한다.
시간을 측정하는 로직을 별도의 공통 로직으로 만들었다.
핵심 관심 사항을 깔끔하게 유지할 수 있다.
변경이 필요하면 이 로직만 변경하면 된다.
원하는 적용 대상을 선택할 수 있다.

스프링의 AOP 동작 방식 설명


가짜 memberService(프록시)를 만든다 —> 가짜를 실행 시킨후 진짜를 실행 시켜준다

memberController에서 memberService.getClass() 를 찍어보면 프록시를 확인해 볼 수 있다.



